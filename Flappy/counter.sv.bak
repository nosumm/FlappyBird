// counter uses win signal to increment score for hexdisplay
module counter(S, Win, Reset, Clock);
  input logic Clock, Reset, Win;
  output logic [2:0] S;
  
  always_ff @(posedge Clock) begin
    if(Reset)
	   S <= 3'b000;
	else if(Win) 
	   S <= S + 3'b001; // S = S + 1
  end
endmodule


module counter_testbench();
	reg clk, Reset, test;
	wire [2:0] S;

	counter dut(S, test, Reset, clk);
	
	parameter CLOCK_PERIOD = 100;
	
	initial clk = 1; 
	always begin 
		#(CLOCK_PERIOD/2); 
		clk = ~clk; 
	end 
	
	initial begin 
						@(posedge clk);
		Reset <= 1; @(posedge clk); 
						@(posedge clk); 
						@(posedge clk); 
						@(posedge clk); 
						@(posedge clk);	
		Reset <= 0; @(posedge clk); 
						@(posedge clk); 
						@(posedge clk);
						@(posedge clk);
						@(posedge clk);
		test <= 1;
						@(posedge clk);

						
		test <= 0;
						@(posedge clk);
		test <= 1;
						@(posedge clk);

						
		test <= 0;
						@(posedge clk);
		test <= 1;
						@(posedge clk);

						
		test <= 0;
						@(posedge clk);
		test <= 1;
						@(posedge clk);
		test <= 1;
						@(posedge clk);

						
		test <= 0;
						@(posedge clk);
		test <= 1;
						@(posedge clk);
		test <= 0;
						@(posedge clk);

						
		test <= 1;
						@(posedge clk);
		test <= 0;
						@(posedge clk);

		Reset <= 1; @(posedge clk); 
						@(posedge clk); 
						@(posedge clk); 
						@(posedge clk); 
						@(posedge clk);
		Reset <= 0; @(posedge clk);
						@(posedge clk); 
						@(posedge clk); 
						@(posedge clk); 
						@(posedge clk); 
						@(posedge clk);
						
						
		$stop; 
	end
endmodule
