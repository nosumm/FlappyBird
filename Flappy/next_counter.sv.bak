// counter uses increment signal to increment score for hexdisplay
module next_counter(S, next_in, Reset, game_over, Clock, next_out);
  input logic Clock, Reset, game_over, increment;
  output logic [3:0] S;
  input next_in;
  output next_out;
  
  
  always_ff @(posedge Clock) begin
    if(Reset | game_over)
	   S <= 4'b0000;
	else if(next_in) 
	   S <= S + 4'b0001; // S = S + 1
  end
  
  always_comb begin
    if(S == 4'b1001) begin // if S = 9
      next_out = 1;
    end else begin 
	   next_out = 0;
	 end
  end
  
  // when 
endmodule


module counter_testbench();
	reg clk, Reset, test, increment;
	wire [3:0] S;

	counter dut(S, test, Reset, clk);
	
	parameter CLOCK_PERIOD = 100;
	
	initial clk = 1; 
	always begin 
		#(CLOCK_PERIOD/2); 
		clk = ~clk; 
	end 
	
	initial begin 
						@(posedge clk);
		Reset <= 1; @(posedge clk); 
						@(posedge clk); 
						@(posedge clk); 
						@(posedge clk); 
						@(posedge clk);	
		Reset <= 0; @(posedge clk); 
						@(posedge clk); 
						@(posedge clk);
						@(posedge clk);
						@(posedge clk);
		test <= 1;
						@(posedge clk);

						
		test <= 0;
						@(posedge clk);
		test <= 1;
						@(posedge clk);

						
		test <= 0;
						@(posedge clk);
		test <= 1;
						@(posedge clk);

						
		test <= 0;
						@(posedge clk);
		test <= 1;
						@(posedge clk);
		test <= 1;
						@(posedge clk);

						
		test <= 0;
						@(posedge clk);
		test <= 1;
						@(posedge clk);
		test <= 0;
						@(posedge clk);

						
		test <= 1;
						@(posedge clk);
		test <= 0;
						@(posedge clk);

		Reset <= 1; @(posedge clk); 
						@(posedge clk); 
						@(posedge clk); 
						@(posedge clk); 
						@(posedge clk);
		Reset <= 0; @(posedge clk);
						@(posedge clk); 
						@(posedge clk); 
						@(posedge clk); 
						@(posedge clk); 
						@(posedge clk);
						
						
		$stop; 
	end
endmodule
